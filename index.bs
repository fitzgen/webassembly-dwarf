<pre class=metadata>
Title: DWARF for WebAssembly Target
Editor: Yury Delendik
Status: FINDING
Shortname: dwarf-webassembly
Abstract: This document describes how existing DWARF format can be extended and used with the WebAssembly binaries.
Markup Shorthands: markdown yes
</pre>
<pre class ="biblio">
{
  "dwarf-spec": {
    "href": "http://www.dwarfstd.org/doc/DWARF5.pdf",
    "title": "DWARF Debugging Information Format. Version 5"
  },
  "source-maps": {
    "href": "https://github.com/WebAssembly/design/pull/1051",
    "title": "Source maps applied to wasm binaries"
  },
  "wasm-linking": {
    "href": "https://github.com/WebAssembly/tool-conventions/blob/master/Linking.md",
    "title": "WebAssembly Object File Linking"
  },
  "wasm-debugging-capabilities": {
    "href": "https://fitzgen.github.io/wasm-debugging-capabilities",
    "title": "WebAssembly Debugging Capabilities"
  },
  "llvm-dbg-value-pilot": {
    "href": "https://reviews.llvm.org/D52634",
    "title": "Add DBG_VALUE with local operands location in WebAssemblyExplicitLocals pass"
  },
  "x-scopes-pilot": {
    "href": "https://gist.github.com/yurydelendik/802f36983d50cedb05f984d784dc5159",
    "title": "Experimental `x-scopes` source maps extension"
  },
  "wasm-dwarf-flow": {
    "href": "https://docs.google.com/drawings/d/17WDtbC4qIzUvdSHsRxw6c4kPcUhTlKJfRDmhywr9Pmo/",
    "title": "WebAssembly DWARF information flow overview"
  }
}
</pre>

# Embedding DWARF data # {#embedding}

The DWARF sections are embedded in the binary WASM files as custom section [[wasm-debugging-capabilities#embeddable-in-wasm|ᴿembeddable-in-wasm]]. The name of the custom section is equal to the DWARF section name as defined in the specification, e.g. `.debug_info` or `.debug_line`. It will allow quickly scan and locate the section's data in a debugger or other tool.

The DWARF format is already compact [[wasm-debugging-capabilities/#compact-in-memory|ᴿcompact-in-memory]]. Furthermore, it is possible to remove DWARF sections from the production binary WASM file and place them into a separate container without modifications [[wasm-debugging-capabilities/#compact-on-disk|ᴿcompact-on-disk]].

See the full list of the sections and their relationship at DWARF Format Specification's Appendix B. [[!dwarf-spec]]


# Relationship with WebAssembly code # {#webassembly-code}

The DWARF information can refer to an instruction pointer or location in memory. In addition to that, special WebAssembly primitives such as locals or globals need to be referenced.

## Instruction Pointer ## {#pc}

The instruction pointer (or PC) is currently defined as WebAssembly bytecode offset, starting from code section body.  The mapping instruction pointer to bytecode offset simplifies resolution between the call stack PC pointer and WebAssembly code debug information [[wasm-debugging-capabilities/#code-to-source|ᴿcode-to-source]]. Many sections, such as `.debug_info`, `.debug_line`, etc., refer to a particular instruction by their bytecode offset, and it will be unique.

It is also trivial to map WebAssembly bytecode offset to the derived native PC, e.g. during AOT or JIT compilation, for a use in a native debugger. 

### .debug_line section ### {#debug_line}

The `.debug_line` section allows mapping between bytecode offset and original source. The relationship between these location types is many-to-one: multiple bytecode offsets may correspond a single original source location [[wasm-debugging-capabilities/#enumerate-location-mappings|ᴿenumerate-location-mappings]].

This information is complete to produce wasm source map file [[!source-maps]].

### .debug_info section code ranges ### {#debug_info_code}

The `.debug_info` section contains information about a compile unit, that is comprised of subprogram/functions entries. Individual function entry contains information about its parameters and variables. This information includes their types [[wasm-debugging-capabilities/#type-of-binding|ᴿtype-of-binding]], the bindings in scopes at a certain locations [[wasm-debugging-capabilities/#bindings-within-a-scope|ᴿbindings-within-a-scope]] and how to calculate a variable value using DWARF expression [[wasm-debugging-capabilities/#reconstruct-a-bindings-value|ᴿreconstruct-a-bindings-value]].

The inlined function is expressed inside the `.debug_info` function entries [[wasm-debugging-capabilities/#inlined-functions|ᴿinlined-functions]] and also contain a proper mapping in the `.debug_line` section.


## Memory Address ## {#memory-address}

The location in memory, e.g. expressions that point to static variables defined on a heap, has the same definition as in traditional architectures.

### .debug_info structures information ### {#debug_info_stucture}

The `.debug_info` section also describes structures [[wasm-debugging-capabilities/#type-of-binding|ᴿtype-of-binding]]. These description include the structure field types and locations. A consumer (e.g. a debugger) can format the variable display based on this type information [[wasm-debugging-capabilities/#reconstruct-a-bindings-value|ᴿreconstruct-a-bindings-value]].

## DWARF Expressions ## {#dwarf-expressions}

WebAssembly does not have registers, which DWARF expressions normally use to calculate the values of original source variables. WebAssembly compilers will use operands stack, locals or globals to store these variables values. To refer locals and globals in DWARF expressions, the built-in language extension of the DWARF expression will be used. The special operator code will be chosen in the range between `DW_OP_lo_user` and `DW_OP_hi_user` (see 7.1 Vendor Extensibility, [[!dwarf-spec]]).

The above extension will allow reading values of locals or globals [[wasm-debugging-capabilities/#reconstruct-a-bindings-value|ᴿreconstruct-a-bindings-value]] (see [[#debug_info_stucture]] above). Compilers need to learn to track all mappings of the original source variables to operands stack locals, or globals (instead of native platform registers), calculate their lifetime and serialize that into `.debug_info` section.

This extension allows separating logically incompatible native platform concepts of registers/memory and WebAssembly specific elements. When DWARF information needed to be transformed for use in the native debugger, e.g. as JIT'ed code, the `DW_OP_WASM_location` extension can be easily replaced with native registers or memory location expression. There is no real advantage to overcomplicate logic of producers and consumers of the DWARF information with artificial mapping scheme that express WebAssembly specific location as CPU registers.

### Proposed DWARF expression extension for locals ### {#dwarf-locals}

The `DW_OP_WASM_location` with code `0xED` can be added to the DWARF expression language. This operation will have two operands.

The first operand defines the type of the WebAssembly location. It is encoded as ULEB128 constant.

The second operand is a location item index and it is encoded as ULEB128 constant.

<table class=index>
  <caption>WebAssembly Location</caption>
  <thead>
    <tr>
      <th>Type</th><th>Description</th><th>Second Parameter</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td><td>Local or Argument</td><td>The index of a WebAssembly function  local/parameter</td>
    </tr>
    <tr>
      <td>2</td><td>Global</td><td>The index of a WebAssembly module global</td>
    </tr>
    <tr>
      <td>3</td><td>Operand Stack Item</td><td>The depth of the item (0 - points the bottom of the stack)</td>
    </tr>
  </tbody>
</table>


# Types information # {#types}

The [[!dwarf-spec]] has the ability to store types information, e.g. in the `.debug_pubtypes` or `.debug_info` sections, that can be used by a debugger to display or pretty print more complex values [[wasm-debugging-capabilities/#types|ᴿtypes]]. The type information can be used by a debugger (or its language server) to properly calculate and execute an expression provided by a user.

See also [[#debug_info_stucture]].

# Usage by tools # {#tools}

Tools, other than a debugger, can consume and mutate the DWARF section information. As a general rule, a tool has to have knowledge about debug information associated with WASM binary file. The relocation sections (see [[!wasm-linking]]) may assist with changing the structure of the code or data section, e.g. in case if some function where removed [[wasm-debugging-capabilities/#fast-to-manipulate|ᴿfast-to-manipulate]]. However, if a function body itself was mutated, a DWARF information needs to be updated or removed.

The proposed above DWARF extensions for WebAssembly are intended to be used by the specialized WebAssembly debuggers or to be transformed into DWARF format that is used in native debuggers.

See also [[wasm-dwarf-flow]].

## Conversion to source maps ## {#source-maps}

At this moment web browsers can use source map to map generated code to original sources. The source maps where created for JavaScript usage, however it is possible to use these for the WebAssembly modules.

The wasm source maps [[!source-maps]] can be generated based on the .debug_line section information [[wasm-debugging-capabilities/#locations|ᴿlocations]]. The `.debug_line` sections, when decoded, allows producing the mappings of wasm file bytecode offsets to the original source locations.

The source file names can be specified in the relative or absolute form. The web platform solutions prefer original sources be provided as text embedded into source maps or published relative to the source map file.

The DWARF sections can be discarded [[wasm-debugging-capabilities/#separable-from-wasm|ᴿseparable-from-wasm]].

Note: It is possible to translate entire DWARF information -- there is a pilot at [[x-scopes-pilot]]. That allows debugger vendors to experiment and verify if all needed information is present.

## Use in WebAssembly debuggers ## {#wasm-debugger}

The following functionality is expected to be implemented in a specialized WebAssembly debugger:

- Read and parse DWARF data
- Evaluate extended DWARF expressions to locate data
- Use type info during formatting of data values


## Use in AOT or JIT compilers ## {#aot-jit}

It is not trivial to adapt native debuggers to support the WebAssembly target. Though native debuggers have a good support for DWARF.

The following functionality is expected to be performed by WebAssembly to native code compilers:

- Read and parser WebAssembly DWARF data
- Transform during compilation:
    * WebAssembly bytecode offsets to native code instruction addresses
    * Translate extended DWARF expressions into DWARF expression operands that use native registers and memory
- Serialize and package transformed DWARF data along with the compiled code
